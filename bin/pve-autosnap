#!/bin/bash
#
# pve-autosnap - Copyright (c) 2018 - Olivier Poncet
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#

# ----------------------------------------------------------------------------
# pve interface definitions
# ----------------------------------------------------------------------------

kvm_manager="/usr/sbin/qm"
lxc_manager="/usr/sbin/pct"

cmd_status="status"
cmd_list_vm="list"
cmd_list_snapshot="listsnapshot"
cmd_create_snapshot="snapshot"
cmd_delete_snapshot="delsnapshot"
pve_minvmid="100"
pve_maxvmid="9999"

# ----------------------------------------------------------------------------
# options
# ----------------------------------------------------------------------------

opt_vmid="help"
opt_keep="1"
opt_minvmid="${pve_minvmid}"
opt_maxvmid="${pve_maxvmid}"
opt_exclude=""
opt_include=""
opt_debug="no"

# ----------------------------------------------------------------------------
# parse the command-line arguments
# ----------------------------------------------------------------------------

if [ "no${0}ne" != "none" ]
then
    self="${0}"
else
    self="pve-autosnap"
fi

if [ "${#}" -gt "0" ] && [ "no${1}ne" != "none" ]
then
    opt_vmid="${1}"
    shift
fi

if [ "${#}" -gt "0" ] && [ "no${1}ne" != "none" ]
then
    opt_keep="${1}"
    shift
fi

# ----------------------------------------------------------------------------
# parse the command-line otions
# ----------------------------------------------------------------------------

while [ "${#}" -gt "0" ]
do
    case "${1}" in
        *=*)
            arg_value="$(expr "${1}" : '[^=]*=\(.*\)')"
            ;;
        *)
            arg_value=""
            ;;
    esac
    case "${1}" in
        --minvmid=*)
            opt_minvmid="${arg_value}"
            ;;
        --maxvmid=*)
            opt_maxvmid="${arg_value}"
            ;;
        --exclude=*)
            opt_exclude="$(echo "${arg_value}" | tr ',' ' ')"
            ;;
        --include=*)
            opt_include="$(echo "${arg_value}" | tr ',' ' ')"
            ;;
        --kvm-manager=*)
            kvm_manager="${arg_value}"
            ;;
        --lxc-manager=*)
            lxc_manager="${arg_value}"
            ;;
        --debug=*)
            opt_debug="${arg_value}"
            ;;
        --debug)
            opt_debug="yes"
            ;;
        *)
            echo "error: unsupported option [${1}]"
            exit 1
            ;;
    esac
    shift
done

# ----------------------------------------------------------------------------
# enable the debug mode if requested
# ----------------------------------------------------------------------------

if [ "${opt_debug}" = "yes" ]
then
    set -x
fi

# ----------------------------------------------------------------------------
# display help if requested
# ----------------------------------------------------------------------------

if [ "${opt_vmid}" = "help" ]
then
    cat << ____EOF
Usage: $(basename ${self}) [ help | <vmid> [ <keep> [OPTIONS] ] ]

Arguments:

    help   display this help and exit
    vmid   specifies the virtual machine id, can be 'all' or 'none'
    keep   specifies the maximum number of snapshot to keep (default is 1)

Options:

    --minvmid={vmid}            specifies the first vmid (default is 100)
    --maxvmid={vmid}            specifies the last vmid (default is 9999)
    --exclude={vmid,vmid,...}   specifies the list of vmid to exclude
    --include={vmid,vmid,...}   specifies the list of vmid to include

PVE options:

    --kvm-manager={path}        specifies the path of the KVM manager ('/usr/sbin/qm')
    --lxc-manager={path}        specifies the path of the LXC manager ('/usr/sbin/pct')

Special options:

    --debug[={yes|no}]          enable/disable the debug mode

____EOF
    exit 0
fi

# ----------------------------------------------------------------------------
# verify the 'keep' argument
# ----------------------------------------------------------------------------

if [ "${opt_keep}" -ge "0" ]
then
    : # no-op
else
    echo "the <keep> argument must be greater than or equal to 0"
    exit 1
fi

# ----------------------------------------------------------------------------
# verify the '--minvmid=<vmid>' argument
# ----------------------------------------------------------------------------

if [ "${opt_minvmid}" -ge "${pve_minvmid}" ] \
&& [ "${opt_minvmid}" -le "${pve_maxvmid}" ]
then
    : # no-op
else
    echo "the minimum vmid is not in the range [${pve_minvmid},${pve_maxvmid}]"
    exit 1
fi

# ----------------------------------------------------------------------------
# verify the '--maxvmid=<vmid>' argument
# ----------------------------------------------------------------------------

if [ "${opt_maxvmid}" -ge "${pve_minvmid}" ] \
&& [ "${opt_maxvmid}" -le "${pve_maxvmid}" ]
then
    : # no-op
else
    echo "the maximum vmid is not in the range [${pve_minvmid},${pve_maxvmid}]"
    exit 1
fi

# ----------------------------------------------------------------------------
# verify the '--exclude=<vmid-list>' argument
# ----------------------------------------------------------------------------

if [ "no${opt_exclude}ne" != "none" ]
then
    for excluded_vm in ${opt_exclude}
    do
        if [ "${excluded_vm}" -ge "${opt_minvmid}" ] \
        && [ "${excluded_vm}" -le "${opt_maxvmid}" ]
        then
            : # no-op
        else
            echo "error: the excluded vmid <${excluded_vm}> is not in the range [${opt_minvmid},${opt_maxvmid}]"
            exit 1
        fi
    done
fi

# ----------------------------------------------------------------------------
# verify the '--include=<vmid-list>' argument
# ----------------------------------------------------------------------------

if [ "no${opt_include}ne" != "none" ]
then
    for included_vm in ${opt_include}
    do
        if [ "${included_vm}" -ge "${opt_minvmid}" ] \
        && [ "${included_vm}" -le "${opt_maxvmid}" ]
        then
            : # no-op
        else
            echo "error: the included vmid <${included_vm}> is not in the range [${opt_minvmid},${opt_maxvmid}]"
            exit 1
        fi
    done
fi

# ----------------------------------------------------------------------------
# if the given vmid is 'all', process vmids with the exclude list then exit
# ----------------------------------------------------------------------------

if [ "${opt_vmid}" = "all" ]
then
    kvm_list="$(${kvm_manager} "${cmd_list_vm}" | grep -v VMID | awk '{ print $1 }')"
    lxc_list="$(${lxc_manager} "${cmd_list_vm}" | grep -v VMID | awk '{ print $1 }')"
    vmid_list="${kvm_list} ${lxc_list}"
    for vmid in ${vmid_list}
    do
        is_excluded="no"
        for excluded_vm in ${opt_exclude}
        do
            if [ "${vmid}" -eq "${excluded_vm}" ]
            then
                is_excluded="yes"
                break;
            fi
        done
        if [ "${is_excluded}" = "no" ] \
        && [ "${vmid}" -ge "${opt_minvmid}" ] \
        && [ "${vmid}" -le "${opt_maxvmid}" ]
        then
            ${self} "${vmid}" "${opt_keep}"
        fi
    done
    exit 0
fi

# ----------------------------------------------------------------------------
# if the given vmid is 'none', process vmids with the include list then exit
# ----------------------------------------------------------------------------

if [ "${opt_vmid}" = "none" ]
then
    kvm_list="$(${kvm_manager} "${cmd_list_vm}" | grep -v VMID | awk '{ print $1 }')"
    lxc_list="$(${lxc_manager} "${cmd_list_vm}" | grep -v VMID | awk '{ print $1 }')"
    vmid_list="${kvm_list} ${lxc_list}"
    for vmid in ${vmid_list}
    do
        is_included="no"
        for included_vm in ${opt_include}
        do
            if [ "${vmid}" -eq "${included_vm}" ]
            then
                is_included="yes"
                break;
            fi
        done
        if [ "${is_included}" = "yes" ] \
        && [ "${vmid}" -ge "${opt_minvmid}" ] \
        && [ "${vmid}" -le "${opt_maxvmid}" ]
        then
            ${self} "${vmid}" "${opt_keep}"
        fi
    done
    exit 0
fi

# ----------------------------------------------------------------------------
# process the given vmid
# ----------------------------------------------------------------------------

echo "=== $(basename ${self}) ${opt_vmid} ${opt_keep} ==="

run="none"

# ----------------------------------------------------------------------------
# check if this is a valid kvm vmid
# ----------------------------------------------------------------------------

if [ "${run}" = "none" ]
then
    if [ "x$(${kvm_manager} "${cmd_status}" "${opt_vmid}" 2>/dev/null)y" != "xy" ]
    then
        run="${kvm_manager}"
    fi
fi

# ----------------------------------------------------------------------------
# check if this is a valid lxc vmid
# ----------------------------------------------------------------------------

if [ "${run}" = "none" ]
then
    if [ "x$(${lxc_manager} "${cmd_status}" "${opt_vmid}" 2>/dev/null)y" != "xy" ]
    then
        run="${lxc_manager}"
    fi
fi

# ----------------------------------------------------------------------------
# check if this is a valid vmid
# ----------------------------------------------------------------------------

if [ "${run}" = "none" ]
then
    echo "error: <vmid> does not look like a valid VM ID"
    exit 1
fi

# ----------------------------------------------------------------------------
# create new snapshot for this vmid
# ----------------------------------------------------------------------------

autosnap_name="autosnap_$(date '+%Y%m%d_%H%M%S')"
autosnap_desc="automatic snapshot"

if [ "${opt_keep}" -gt "0" ]
then
    ${run} "${cmd_create_snapshot}" "${opt_vmid}" "${autosnap_name}" -description "${autosnap_desc}"
fi

# ----------------------------------------------------------------------------
# delete old snapshots for this vmid
# ----------------------------------------------------------------------------

autosnap_list="$(${run} "${cmd_list_snapshot}" "${opt_vmid}" | grep "^autosnap_" | awk '{ print $1 }' | sort)"
autosnap_left="$(echo "${autosnap_list}" | wc -w)"

for autosnap_item in ${autosnap_list}
do
    if [ "${autosnap_left}" -gt "${opt_keep}" ]
    then
        ${run} "${cmd_delete_snapshot}" "${opt_vmid}" "${autosnap_item}"
    fi
    autosnap_left=$((autosnap_left - 1))
done

# ----------------------------------------------------------------------------
# End-Of-File
# ----------------------------------------------------------------------------
